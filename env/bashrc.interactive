# Set the prompt when in interactive mode, even if we ran already.

l_ps1='\h:\w\$ '
l_ps2='> '
case "$TERM" in
  xterm|linux|ansi|screen|[Cc]ygwin|rxvt*)
     l_ps1='\033[01;35m\h:\w/\033[0m\n\$ '
     l_ps2='\033[01;34m>\033[0m '
     ;;
esac

if [ -n "${INTERACTIVE}" ]; then
    unset PROMPT_COMMAND
    export PS1="$l_ps1"
    export PS2="$l_ps2"
fi

############################################################################
############################################################################
#
# Source the rest of this file only once.
#
############################################################################
############################################################################


if [ "${INTERACTIVE}" = "ran" ]; then
    return
fi

############################################################################
############################################################################


echo "Setting up for interactive shell..."


# Comment out/set to "" if you're not using the GNU utils.
#
GNU_VERBOSE="-v"
GNU_LS_COLOR="--color"
export PSGREP_OPTS="flw"
BASH_INPUTRC="${HOME}/.bashrc.emacs-inputrc"
if [ \! -f $BASH_INPUTRC ]; then
    BASH_INPUTRC="/etc/bashrc.emacs-inputrc"
fi

# terminal-specific stuff
umask 022
case $TERM in
  xterm|linux|ansi|screen|[Cc]ygwin|rxvt*)
    stty erase '^h' kill '^u' intr '^c' susp '^z'
    ;;
  *)
    stty erase '^?' kill '^u' intr '^c' susp '^z'
    ;;
esac


########################
#
# Environment variables
#
########################

MORE=-f
LESS=-MiXF
MANOPT="--sections=3:1:8:6:2:4:5:7 --all"
[ -x /usr/bin/less ] && LESSBIN="/usr/bin/less"
MOREBIN="/bin/more"
PAGER="${LESSBIN:-${MOREBIN}}"
export MORE LESS MANOPT PAGER

# Note:  Prompt set at top of this file.
#export PS1 PS2

# Color-LS support
if [ -n "${GNU_LS_COLOR}" -a -z "${LS_COLORS}" ]; then
    eval `dircolors --sh /etc/DIR_COLORS`
    export LS_COLORS
fi

# Some other Mozilla envvars
#source /etc/java-path.conf
#export CLASSPATH="${CLASSPATH}:${MOZILLA_HOME}/java/classes"


# Used by GJiten
LANGUAGE=${LANG}
export LANGUAGE


# Set the shell to use emacs style input editing (yes, we need both the
# "set keymap" and "set editing-mode" commands).  Do not use 
# "bind -m emacs", as this will reset the key map.
if [ -e "${BASH_INPUTRC}" ]; then
    source ${BASH_INPUTRC}
else
    # "Safe" mode
    set keymap emacs
    set editing-mode emacs
fi


####################
#
# Functions
#
####################


# Create a function to page a command with additional options
pagecommand() {
    local cmdname
    local po=""
    local foldIt=""

    if [ "$1" = "-o" ]; then
       shift
       po="$1"
       shift
    fi
    if [ "$1" = "-f" ]; then
        foldIt='y'
        shift
    fi

    cmdname=${1}
    shift
    if [ -z "$foldIt" ]; then
        ${cmdname} "$@" 2>&1 | ${PAGER:-more} ${po}
    else
        ${cmdname} "$@" 2>&1 | fold -s | ${PAGER:-more} ${po}
    fi
}

# The classic tar-based recursive copy
tarcp() {
    local srcdir targdir oldpwd

    if [ "x$1" = "x" -o "x$2" = "x" ]; then
        echo "Usage: tarcp <srcdir>  <destdir>"
        echo "The contents of \"<srcdir>\" are copied INTO \"<destdir>\"."
        echo "Keep this in mind."
        return 1
    fi
    srcdir="$1"
    oldpwd=`pwd`
    case "$2" in
        /)
            targdir="$2"
            ;;
        *)
            targdir="$oldpwd/$2"
            ;;
    esac
    cd $srcdir
    tar --atime-preserve -cf - . | (cd $targdir; tar -xvpf -)
    cd $oldpwd
}

# The classic cpio-based copy
cpiocp() {
    local srcdir targdir oldpwd

    if [ "x$1" = "x" -o "x$2" = "x" ]; then
        echo "Usage: cpiocp <srcdir>  <destdir>"
        echo "The contents of \"<srcdir>\" are copied INTO \"<destdir>\"."
        echo "Keep this in mind."
        return 1
    fi
    srcdir="$1"
    oldpwd=`pwd`
    case "$2" in
        /)
            targdir="$2"
            ;;
        *)
            targdir="$oldpwd/$2"
            ;;
    esac
    cd $srcdir
    # -m == --preserve-modification-time
    # -d == --make-directories
    # -u == --unconditional == overwrite files
    # -depth := do a depth-first find, printing leaves first.
    find . -depth -print0 | cpio -0 --pass-through -mduv $targdir
    cd $oldpwd
}

# A core routine for creating a cpio archive.
do__cpio__engine() {
    local myName do_usage mode arfile xopts cpioOpts vOpt \
        srcdirs compress catbin

    myName="do__cpio__engine"
    if [ "$1" = "--name" ]; then
        shift
        myName="$1"
        shift
    fi

    do_usage=''
    mode=''
    arfile=''
    xopts='-d -u -m'
    cpioOpts=''
    vOpt=''
    srcdirs=''
    compress=''

    while [ -n "$1" ]; do
        case "$1" in
            # -o == --create := "copy-out" mode
            -c|--create)
                mode='-o'
                ;;
            # -i == --extract := "copy-in" mode
            -x|--extract)
                mode='-i'
                ;;
            # -t == --list
            -t|--list)
                mode='-t'
                vOpt='-v'
                ;;
            -v|--verbose)
                vOpt='-v'
                ;;
            -f|-F|--file)
                shift
                arfile="$1"
                if [ -z "$vOpt" ]; then
                    vOpt='-V'
                fi
                ;;
            -z|--gzip)
                compress="-z"
                ;;
            -j|-b|--bzip2|--bz2)
                compress="-b"
                ;;
            -[kK]|--keep)
                xopts='-d -m'
                ;;
            -o|--opts|--cpio-opts)
                shift
                cpioOpts="$cpioOpts $1"
                ;;
            -)
                arfile=''
                ;;
            --)
                shift
                srcdirs="$@"
                break
                ;;
            -*)
                do_usage='y'
                break
                ;;
            *.cpio|*.cpio.gz|*.cpio.bz2)
                arfile="$1"
                ;;
            *)
                srcdirs="$srcdirs $1"
                ;;
        esac
        shift
    done

    [ -z "$arfile" ] \
        || [ -z "$mode" ] \
        || [ "$mode" = "-o" -a -z "$srcdirs" ] \
        && do_usage='y'

    if [ -n "$do_usage" ]; then
        echo "Usage: $myName [<Options>] <archivespec> <dir|file> ..."
        echo ""
        echo "<archivespec>:  One of:"
        echo "    -f|-F|--file <filename>"
        echo "    <filename>.cpio[.gz|.bz2]"
        echo "    -"
        echo ""
        echo "<Options> := <mode> [-v] [-k] [-z|-b] [--cpio-opts]"
        echo "   -v|--verbose"
        echo "   -k|-K|--keep"
        echo "   -z|--gzip"
        echo "   -j|-b|--bz2|--bzip2"
        echo "   -o|--opts|--cpio-opts <optionList>"
        echo "       \"<optionList>\" is a space-separted string of options to"
        echo "       pass to \"cpio\""
        echo "   <mode> is one of:"
        echo "      -c|--create"
        echo "      -x|--extract"
        echo "      -t|--list"
        echo "   --"
        echo "      Stops all option processing.  All remaining args are"
        echo "      treated as files to directories to archive."
        echo ""
        echo "The most recent option overrides all others.  Filename"
        echo "extensions override the \"--gzip\" and \"--bzip2\" args."
        echo ""
        echo "The \"--list\" and \"--extract\" modes ignore the \"<dir|file>\""
        echo "args."
        return 1
    fi

    # Determine the compression type
    case "$arfile" in
        *.cpio)
            compress=''
            ;;
        *.cpio.gz)
            compress='-z'
            ;;
        *.cpio.bz2)
            compress='-b'
            ;;
    esac

    cpioOpts="$cpioOpts $vOpt"
    if [ "$mode" = "-o" ]; then

        if [ "$compress" = "-b" ]; then
            find $srcdirs -depth -print0 | \
                cpio -0 -o $cpioOpts | bzip2 >$arfile
        elif [ "$compress" = "-z" ]; then
            find $srcdirs -depth -print0 | \
                cpio -0 -o $cpioOpts | gzip >$arfile

        else
            find $srcdirs -depth -print0 | \
                cpio -0 -o $cpioOpts --file=$arfile
        fi

    else 

        if [ "$mode" = "-i" ]; then
            cpioOpts="$cpioOpts $xopts"
        fi

        catbin="cat"
        if [ "$compress" = "-b" ]; then
            catbin="bzcat"
        elif [ "$compress" = "-z" ]; then
            catbin="zcat"
        fi

        $catbin $arfile | cpio $mode $cpioOpts

    fi     
}

# Functions & Aliases that use do__cpio__engine
cpiov() {
    local arfile copt
    arfile=''
    copt=''
    while [ -n "$1" ]; do
        case "$1" in
            -z|--gzip|-j|-b|--bzip2|--bz2)
                copt="$1"
                ;;
            -*)
                arfile=''
                break
                ;;
            *)
                [ -z "$arfile" ] && arfile="$1"
                ;;
        esac
        shift
    done

    if [ -z "$arfile" ]; then
        echo "Usage: cpiov [-z|-b] <archiveFile>"
        return 1
    fi

    do__cpio__engine --name "cpiov" $copt --file "$arfile" --list
}

mkcpio() {
    local arfile copt err
    arfile=''
    copt=''
    err=''

    case "$1" in
        -z|--gzip|-j|-b|--bzip2|--bz2)
            copt="$1"
            ;;
        -*)
            err='y'
            ;;
    esac
    shift

    arfile="$1"
    shift
    case "$arfile" in
        -*)
            err='y'
            ;;
    esac

    if [ -n "$err" -o -z "$arfile" ]; then
        echo "Usage: mkcpio [-z|-b] <archiveFile> <dir|file> ..."
        return 1
    fi

    do__cpio__engine --name "mkcpio" $copt --file "$arfile" --create "$@"
}

uncpio() {
    local arfile copt err
    arfile=''
    copt=''
    err=''

    case "$1" in
        -z|--gzip|-j|-b|--bzip2|--bz2)
            copt="$1"
            ;;
        -*)
            err='y'
            ;;
    esac
    shift

    arfile="$1"
    shift
    case "$arfile" in
        -*)
            err='y'
            ;;
    esac

    if [ -n "$err" -o -z "$arfile" ]; then
        echo "Usage: uncpio [-z|-b] <archiveFile>"
        return 1
    fi

    do__cpio__engine --name "uncpio" $copt --file "$arfile" --extract
}
alias jpwcpio='do__cpio__engine --name "jpwcpio"'


# custom form of ps
ps_grep() {
    if [ "x${1}" = "x" ]; then
           ps -e${PSGREP_OPTS} | ${PAGER} ${LESSBIN:+-E}
    else
           ps -e${PSGREP_OPTS} | grep "PID\|$1" | grep -v "grep" | \
               ${PAGER} ${LESSBIN:+-E}
    fi
}

# Fix mangled xterm titles
fix_xterm_title() {
    echo -ne "\033]2;${1}\007"
}


# Run a GUI program in the background from a terminal
runx() {
    local runlog use_sudo xtoolwaitOpts toDesk

    if [ -z "$*" ]; then
        set -- --help
    fi
    case "$*" in
        -h|--help)
            echo -n "runx [-s] [--desk <n>] [xtoolwait-ops [--]]"
            echo " command [cmd-opts]"
            echo ""
            echo "-s:  Run using 'sudo'"
            echo "--desk <n>:  Open program on desktop '<n>"
            echo ""
            echo "N.B. - Some xtoolwait options are ignored."
            return 0
            ;;
    esac

    xtoolwaitOpts=""
    toDesk=''
    use_sudo=''
    while [ -n "$1" -a "$1" != "--" ]; do
        # Look for xtoolwait opts -timeout, -display, -pid
        # as well as -s and --desk
        case "$1" in
            -s)
                use_sudo='y'
                ;;
            --desk)
                case "$2" in
                    -*)
                        echo "Error:  Option '$1' requires an argument"
                        return 1
                        ;;
                esac
                shift
                toDesk="$1"
                ;;
            -timeout|-display)
                case "$2" in
                    -*)
                        echo "Error:  Option '$1' requires an argument"
                        return 1
                        ;;
                esac
                xtoolwaitOpts="$xtoolwaitOpts $1 $2"
                shift
                ;;
            -pid)
                xtoolwaitOpts="$xtoolwaitOpts $1"
                ;;
            -*)
                echo "runx:  Unknown/unsupported option:  '$1'"
                return 1
                ;;
            *)
                break
                ;;
        esac
        shift
    done

    if [ -n "$toDesk" ]; then
        if type -t wmctrl >/dev/null; then
            wmctrl -s $toDesk
        fi
    fi

    runlog="/tmp/runx-${USER}.log"
    if type -t xtoolwait >/dev/null; then
        if [ -n "$use_sudo" ]; then
            sudo xtoolwait $xtoolwaitOpts "$@" >>$runlog 2>&1
        else
            xtoolwait $xtoolwaitOpts "$@" >>$runlog 2>&1
        fi
    else
        echo "Error\!  xtoolwait isn't installed\!"
        echo "Running as a background job and disowning..."
        echo ""
        if [ -n "$use_sudo" ]; then
            sudo "$@" >>$runlog 2>&1 &
        else
            "$@" >>$runlog 2>&1 &
        fi
        disown -h
    fi
}


#################################################################
#
# set up default aliases for bash
#
#################################################################


#
# *Cmdline Interface Customizations*
#

alias pd=pushd

alias =clear

#alias lo=logout
alias lo=exit

alias pwd='echo $PWD'
alias envv='pagecommand set'
if type -t where >/dev/null; then
    alias where='which -a'
fi

alias v="${PAGER} ${LESSBIN:+-r}"
alias fv="pagecommand ${LESSBIN:+ -o -r} fold -s"
if type zless >/dev/null; then
    alias zv="pagecommand -f zless -R"
else
    alias zv="pagecommand -f zcat"
fi
if type bzless >/dev/null; then
    alias bv="pagecommand -f bzless -R"
else
    alias bv="pagecommand -f bzcat"
fi


#
# *Core System Cmds*
#

alias man='LESS=${LESS}r man'

o_gnu_ls="${GNU_LS_COLOR}" # ${GNU_LS_COLOR:+-h}"
o_gnu_dir="${o_gnu_ls} ${GNU_LS_COLOR:+-h}"
o_ls="-F -C ${o_gnu_ls}"
o_dir="-F -l ${o_gnu_dir}"
o_less_ls="${LESSBIN:+ -o '-ReF'}"
alias ls="pagecommand $o_less_ls ls ${o_ls}"
alias lsa="pagecommand $o_less_ls ls ${o_ls} -a"
alias dira="pagecommand $o_less_ls ls ${o_dir} -a"
alias dir="pagecommand $o_less_ls ls ${o_dir}"
alias ll="pagecommand $o_less_ls ls -l ${o_ls/-C/}"
alias vdir="pagecommand $o_less_ls vdir -F ${o_gnu_ls}"
unset o_dir o_ls o_gnu_ls o_gnu_dir o_less_ls

#unalias rm
#unalias mv
#unalias cp
alias rm="rm ${GNU_VERBOSE}"
alias mv="mv ${GNU_VERBOSE}"
alias cp="cp ${GNU_VERBOSE}"

alias psa="ps_grep '-v root'"
alias psu="ps_grep"
alias psgrep=ps_grep
alias myjobs="ps_grep ${USER}"


#
# *Archivers*  [tar/cpio]
#

r_tls="tar -tvf"
r_tzv="${r_tls/-t/-zt}"
r_tbv="${r_tzv/-z/-j}"
alias tls="pagecommand ${r_tls}"
alias tzv="pagecommand ${r_tzv}"
alias tbv="pagecommand ${r_tbv}"
unset r_tls r_tzv r_tbv

alias tarzf='tar -zcvf'
alias tarbf='tar -jcvf'

alias zipv="pagecommand unzip -l"

alias czv="cpiov -z"
alias cbv="cpiov -b"
alias cpiozf='mkcpio --gzip'
alias cpiobf='mkcpio --bzip2'


# *Misc*
#

alias gz="gzip -9v"

#if type emacs >/dev/null; then
#    alias emacs="$(type -p emacs) --custom-options-here"
#fi

alias locn="pagecommand locate"
alias manfile="pagecommand nroff -man"

# Not needed if using the 'clean.sh' symlink to this script.
#alias clean="file-purger.sh"


#
# Platform/OS-Specific
#

case ${OSTYPE} in
    [Cc]ygwin)
        function abspath { wa="$(cygpath -ma $1)"; cygpath -ua "$wa"; }
        alias abscwd='cd "$(abspath $PWD)"'
        stty eol '^j' eol2 '^m'
        export PSGREP_OPTS="flW"
        export CYGWIN="winsymlinks ntea"
        ;;

    *linux*)
        # *NetStuff*
        #
        alias ftp='ncftp'

        # Misc
        #
        alias xwin="/etc/LocalSys/utilities/x_at_login.sh"
        alias eject_cdrw="eject scd0"
        alias run_synaptic='runx -s synaptic'
        alias odx='od -A x -t x1z'
        ;;
esac


# Final Cleanup Stuff
#
unset GNU_LS_COLOR
unset GNU_VERBOSE
unset BASH_INPUTRC
INTERACTIVE="ran"


##################
# Local Variables:
# mode: Shell-script
# sh-shell: bash
# End:
